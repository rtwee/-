# 实模式与保护模式

实模式与保护模式都是CPU的工作模式，实模式是早期CPU的工作方式，而保护模式是现代CPU运行的模式。在计算器启动过程中，先在实模式下运行，后进入保护模式。之所以这么做，是为了兼容早期的实模式。

____

## 一、8086实模式

### 1.1 8086介绍

1978年英特尔的8086微处理器横空出世，该处理器型号是面向个人电脑，**奠定了x86架构的基础**，下面是8086的实物图

<img title="" src="https://img.ithome.com/newsuploadfiles/2024/6/a989b181-cf03-40ea-bf63-71a3416d0e76.jpg?x-bce-process=image/format,f_avif" alt="" data-align="inline">

____

### 1.2 8086引脚定义

可以看出8086CPU具有40个引脚，引脚定义如下：

<img title="" src="https://img2024.cnblogs.com/blog/2795476/202407/2795476-20240704165105936-351885611.png" alt="2795476-20240704165105936-351885611" data-align="center">

引脚分类：

+ 电源Vcc（40），地线（1）

+ 地址/数据引脚
  地址/数据 **分时复用**引脚 <mark>AD0-AD15</mark>:传输地址时位单项输出，传送数据时为双向的输入输出

+ 地址状态
  **分时复用**引脚<mark>A16/S3-A19/S6</mark>:输出、三态引脚
  
  > 三态电路可提供三种不同的输出值：逻辑“0”，逻辑“1”和高阻态。高阻态主要用来将逻辑门同系统的其他部分加以隔离。例如双向I/O电路和共用总线结构中广泛应用三态特性。
  > 
  >        高阻态是一个数字电路里常见的术语，指的是电路的一种输出状态，既不是高电平也不是低电平，如果高阻态再输入下一级电路的话，对下级电路无任何影响，和没接一样，如果用万用表测的话有可能是高电平也有可能是低电平，随它后面接的东西定的。（源自百度百科）
  > 
  > 原文链接：https://blog.csdn.net/weixin_46013401/article/details/111931180

+ 控制引脚

> ```
> NMI（17）：非屏蔽中断请求信号，不受IF影响，此信号一出现，当前指令，执行结束后立即进行中断处理。
> 
> INTR（18）：可屏蔽中断请求信号，输入高电平有效。
> 
> CLK（19）：系统时钟，输入
> 
> RESET（21）：复位信号，输入，高电平有效。复位信号使处理器马上结束现行操作，对处理器的内部寄存器进行初始化
> 
> READY（22）：数据准备好信号线，输入，高电平有效，由存储器或I/O端口发来。CPU在每个总线周期的T3状态对READY采样，若为低电平，则自动插入一个或几个等待状态Tw，直到变为高电平才能进入T4状态
> 
> TEST（23）：等待测试信号，输入，CPU执行 WAIT指令时，每隔5个时钟周期对引脚进行一次测试，若为高电平，CPU处于等待状态；低电平时执行下一条指令。
> 
> RD（32）：读控制信号，输出。RD=0，表示执行一个对存储器或I/O端口的读操作。
> 
> BHE/S7（34）：高八位数据总线允许/状态复用引脚输出。
> 
> MN/MX（33）：最小/最大工作方式控制信号，输入。接高电平时为最小工作方式。...大家了解一下即可
> ```

CPU除了能够访问内存，还能访问硬件，这都是通过总线来实现的。

____

### 1.3 总线

总线的是一个<mark>公共的线路</mark>，负责把携带的信息在计算机的各个部件中进行传输。

按照传输信息内容的不同，总线可以分为三种：

+ 数据总线

+ 地址总线

+ 控制总线

不同系列CPU的参数如下：

<img title="" src="file:///E:/笔记/操作系统真相还原/0 杂项/图片资源/loading-ag-736.png" alt="loading-ag-738" data-align="center">

可以看出8086的**地址总线宽度20位 内、外数据总线宽度16位**（详细参考[总线笔记](..\杂项\1.总线.md)）

### 1.4 <mark>分段机制</mark>

在8086时代，CPU和内存都非常昂贵，CPU和寄存器的宽度都是16位的，在没特殊处理的情况下，16位寄存器的寻址范围是：0-0xffff,最大的寻址空间是2^16=64KB。而使用16位寄存器的8086的地址总线宽度是**20位**，最大寻址的内存地址是1MB。这就是分段机制的由来，使用多段来表示一个地址。

段由三个部分组成：

+ 段基址：段的初始地址

+ 段界限：表示段的长度，决定了段的最大偏移量

+ 段属性：表示段是否刻度、可写以及权限

为了实现分段，8086引入了<mark>段寄存器</mark>：**CS（代码段寄存器）、DS（数据段寄存器）、ES（附加段寄存器）、SS(栈段寄存器)**

----

## 二、保护模式

### 2.1 平坦模式

在8086普及之后，人们发现系统中存在安全问题，操作系统和应用程序之间没有隔离，每个程序都可以随意访问其他程序的地址，容易对其他程序甚至是操作系统造成破坏。因此80286孕育而生，80286 提出了“**保护模式**”的概念，采用24位地址线，16位的CPU和通用寄存器。虽然有16MB的内存，但是受限于16位的寄存器要想访问较大的内存区域，就需要频繁的切换段基址，非常影响计算机性能。

很快Intel推出了80386系列产品，采用32位 地址总线、CPU以及通用寄存器。此时**已经不需要分段机制了，但是为了向前兼容，任然保留了分段机制**，只是在保护模式下，段基址变成了0。操作系统层不再分段，进入了**平坦模式**。

### 2.2 80386寄存器

80386的寄存器有三类：

1. 通用寄存器。8个通用寄存器，是对8086的16位寄存器的扩展（EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP）

2. 段寄存器：段寄存器CS、DS、SS、ES、FS、GS，段寄存器还是16位的没有扩展

3. 状态和指令寄存器:EIP是32位的，同时增加了<mark>EFLAGS</mark>

<img title="" src="file:///E:/笔记/操作系统真相还原/0 杂项/图片资源/a6de6151-45eb-4ff6-b815-80f22d3b1563.png" alt="loading-ag-740" data-align="center">

保护模式是如何进行保护的呢?还得看后面的段描述符和分页机制才能知道。

____

## 三、段描述符

### 3.1 全局描述符表

到了保护模式下，内存段不再是一个简单的**段基址**，段增加了很多属性信息，这些新增的属性信息来确保应用程序间内存的隔离。

在保护模式下，不同的**内存段**需要在**全局描述符表（GDT）** 中进行注册。

### 3.2 段描述符

段描述符就是对**不同内存段的属性描述**，它的结构如下：

<img title="" src="file:///E:/笔记/操作系统真相还原/0 杂项/图片资源/acf92b3e-4582-4461-a432-a9f44c03af2d.png" alt="loading-ag-742" data-align="center">

属性描述

> ```
> G:段界限的单位（limit总共就20位 ，4G需要 4K * 2^20）
>     0：段界限单位1字节
>     1：段界限单位4K字节
> S:段类型 
>     0：系统段
>     1：数据段
> 描述符：描述符的类型  
>     当为系统段时: 描述符除了GDT还有LDT、TSS、任务们、调用门以及各种门描述符，这个TYPE用来标记类型
>     当为非系统段时：
>         代码段：分别代表：X（执行） R（读） C（一致性代码段） A（不需要维护，创建时创为0）
>         数据段：X（执行） W（写） E（扩展方向）              A 
> P:是否存在于内存
>     0：不存在
>     1：存在
> AVL:是否可用，对用户而言
> L:用来设置代码段位数
>     0:32位
>     1:64位
> D/B:用来只是有效地址 及 操作数的大小
>     代码段： 0有效地址和操作数大小是16位  1有效地址和操作数大小是32位
>     数据段： 0栈是16位 1栈是32位
> DPL:特权等级
>     00:0特权
>     01:1特权
>     10:2特权
>     11:3特权
> ```

一个段描述符用来定义一个内存段。我们的代码段、数据段、栈段等，多个内存段各自要占用一个段描述符，这些段描述符放在哪里呢？答案就是<mark>全局描述符表GDT</mark>，将表加载到GDT Register中即可。GDTR是个**48位寄存器**

<img title="" src="file:///E:/笔记/操作系统真相还原/0 杂项/图片资源/c23da98f-02ec-43f6-80de-10b3a83a6c1f.png" alt="loading-ag-744" data-align="center">

将 段描述符放在一块连续的地址空间，并将该起始地址，和段界限加载到GDT寄存器中即可（命令是lgdt）。 

### 3.3 选择子

既然现在已经开始要用段描述符来进行段地址的访问了，那之前的各个段肯定没法直接使用了，因此引出了选择子的概念。保护模式下各个段使用选择子来进行段的访问，选择子结构如下：

<img title="" src="file:///E:/笔记/操作系统真相还原/0 杂项/图片资源/4cb86cdf-317b-4297-a9a8-68719d1cd341.png" alt="loading-ag-746" data-align="center">

属性描述

> ```
> TI:
>     0表示GDT中的描述符
> RPL:特权级
> ```

<img title="" src="file:///E:/笔记/操作系统真相还原/0 杂项/图片资源/97779dc6-e1a7-4d15-b264-8a5bcacfc526.png" alt="loading-ag-748" data-align="center">

那保护模式下使用段描述符是如何实现程序隔离的呢？回答这些问题，仅仅掌握段描述符还是不够的，但起码给我们了启发。在选择子中有RPL，RPL作为选择子的特权等级，而段描述符中存在DPL是段的访问权限。这种权限的设置，可以在一定程度上增加系统的安全性。而完整的程序隔离实则需要分页基址进行配合，目前只能掌握到这。

## 四、保护模式打开步骤

1）打开A20

8086以及8088采用的20位地址线，当地址超过1MB的空间是怎么办呢，其实这时高位会被丢弃，形成了“环回地址”。但是到了80286时期，地址线变成了24位，此时要是超出了1M空间并不会进行环回，为了解决这个问题就出现了一个控制器，被称为A20Gate。

    如果A20Gate打开，那么超出20位的部分也会进行访问

    如果A20Gate关闭，超出部分会像8086那样“环回”

2）加载gdt

3）将cr0的pe位置1

<img title="" src="file:///E:/笔记/操作系统真相还原/0 杂项/图片资源/cc8b0589-9abe-483f-9df7-ccad9d6ecb7f.png" alt="loading-ag-750" data-align="center">
