# 虚拟内存 与 内存分页机制

目前我们直接在内存分段下进行工作，运行程序只有一个loader，并没有出现什么问题。但是试想一下，如果有多个程序运行，内存无法容纳新的进程，或者之前运行后被换出到硬盘中的内存段重新装到内存时没有连续的空间了该怎么办呢？

![loading-ag-1524](./0%20杂项/图片资源/dbd86dcc-51aa-431a-93ba-46bbfe372664.png)

+ 可以等待C完成后腾出空间去运行D（但是要等待C完成）

+ 也可以将段A3或者段C1换出到硬盘上（硬盘速度很慢）

导致这个问题的根本就是现在的内存地址是连续的线性地址，如果解除这种连续的映射关系，则可以解决这个问题。CPU种为了解决该问题，提供了页表功能。

____

## 一、一级页表

为了解除这种线性的映射关系，我们引出了页表的概念，从一级页表入手，将每个虚拟地址与一个相同大小的虚拟地址一一对应。一级页表的结构如下：

<img title="" src="./0 杂项/图片资源/e7e412a3-cec9-493b-906b-5db627f4e4f1.png" alt="loading-ag-1604" data-align="center">

由于有了线性地址到真实物理地址的映射，因此经过段部件输出的线性地址有了新的名字：虚拟地址。这样可以解除线性的映射关系，可是目前还存在一个问题就是 该映射表的大小过大，4G的内存空间只够放一个这种映射表。为了解决这个问题，我们放大每个分页中的项对应的物理空间大小，这样就可以使用更少的内存来对物理空间进行管理。

<img title="" src="./0 杂项/图片资源/8e20771e-33dc-41a1-8922-aeab71be9f93.png" alt="loading-ag-1651" data-align="center">

我们使用高20位来表示页表项，每个页表项对应4K大小的块，这样就可以减少页表的大小。此时虚拟地址的转换流程如下：

<img title="" src="./0 杂项/图片资源/bb4b9288-5055-40ea-a28f-1fb093cdf48f.png" alt="loading-ag-1660" data-align="center">

0x1234分为高20位0x1 和 低12位0x234。首先根据0x1找到以及页表对应的地址0x9000,然后加上0x234偏移地址，得到0x9234.

一级页表看上去天衣无缝，但实则存在很多问题：

+ 当占满4GB空间时，需要4M的空间来存储页表

+ 一级页表种所有的地址空间必须明确确定

+ 我们知道每个进程有自己的页表，若每个页表需要4M的空间，这会占用大量的空间

为了解决这些问题，二级页表孕育而生。

## 二、二级页表

### 2.1 耳机页表结构

二级页表原理：页目录表种存放页表地址，而页表中则是真实对应的物理内存块。通过  页目录项 + 页表项 + 偏移地址确定物理地址。结构如图所示:

<img title="" src="./0 杂项/图片资源/0b1db785-bfe9-4427-a381-01ffdb963148.png" alt="loading-ag-1686" data-align="center">

### 2.2 二级页表翻译流程

此时的地址翻译工作流程如下：

<img title="" src="./0 杂项/图片资源/e3aa8df0-c95b-4dbc-8d42-d4da3f6e4dfc.png" alt="loading-ag-1699" data-align="center">

此时虚拟地址表示如下：

<img title="" src="./0 杂项/图片资源/39ddbd38-4390-4c0b-9274-35b2063511a4.png" alt="loading-ag-1977" data-align="center">

这样使用二级页表，只需要一个4KB的空间就可以表示4GB的物理空间范围。也解决了一级页表存在的问题。

### 2.3 二级页表中的内容

由于我们每个表项中的地址都是以4K的整数倍数开始的，因此表项中的低端12位是可以用作属性位的，各个项的结构如下：

![loading-ag-2004](./0%20杂项/图片资源/575059c1-87ef-4508-9df9-e3b262e8bacb.png)

属性含义：

> ```
> P:存在
>     0不在内存中
>     1在内存中
> RW:读写为
>     0可读不写
>     1可读可写
> US:User/Supervisor
>     0超级用户
>     1普通用户
> PWT:写透位
>     1:通写，不仅是内存还是高速缓存
>     0:我们直接设置0就行
> PCD:高速缓存禁止位
>     0进制
> A:访问位
>     1:表示被CPU访问过了
> D:脏页位
>     当CPU写页面时置为1，只会影响页表项
> PAT：
> G:全局位
>     1表示全局，会在快表TLB种存储，这样不用频繁的去转换地址了
>     0表示不是
> AVL:有效位 还是CPU自己来维护
> ```

## 三、开启分页机制

1)准备页目录表和页表

2)将页表地址写入控制寄存器cr3

<img title="" src="./0 杂项/图片资源/296abe27-89c1-4f0a-8684-5d6af7b75768.png" alt="loading-ag-2853" data-align="center">

3)寄存器cr0的PG位置为1

## 四、设计示例

<img title="" src="./0 杂项/图片资源/paint-board.png" alt="loading-ag-2966" data-align="center">

在设置中，将低端的3G作为用户空间，高端1G做内核空间。

在这个设计中初始化时，使用了低端的1M做内核空间，这样页表0的前256个页表项都指向了低端的1M内存。因此有以下要注意的

+ PDE768对应0xc00以上的内核空间它应该和PDE0指向同一个位置（因为我们设置这块为内核,启动保护模式前只能访问低端1M我也不想破坏）

+ PDE1023 以及 PTE1023都是指向自己本身的，通过这种方法可以修改页表和页目录项中的内容
